# FineGrainedQueue

Реализация односвязного списка на C++ с мелкогранулярной блокировкой для потокобезопасной вставки узлов.

## Описание

`FineGrainedQueue` — класс для вставки узла с числом `value` на позицию `pos` в список.  
Каждый узел содержит:
- Число (`int value`).
- Указатель на следующий узел (`Node* next`).
- Мьютекс (`std::mutex* node_mutex`).

Класс поддерживает:
- Указатель на начало списка (`Node* head`).
- Общий мьютекс (`std::mutex* queue_mutex`).
- Метод `insertIntoMiddle(int value, int pos)` для вставки.
- Метод `printList()` для вывода списка.
- Деструктор для очистки памяти.

Вставка использует **hand-over-hand** блокировку для потокобезопасности.

## Возможности

- Потокобезопасная вставка узла на любую позицию или в конец.
- Мелкогранулярная блокировка с мьютексами на узлы.
- Очистка памяти в деструкторе.

## Установка

1. Клонируйте репозиторий:
   ```bash
   git clone https://github.com/your-username/FineGrainedQueue.git

Перейдите в папку проекта:
bashcd FineGrainedQueue

Скомпилируйте код:
bashg++ -o queue main.cpp -std=c++11 -pthread

Запустите программу:
bash./queue


Пример использования
main создаёт список [5] и вставляет узлы:

insertIntoMiddle(10, 1) → [5] -> [10]
insertIntoMiddle(15, 1) → [5] -> [15] -> [10]
insertIntoMiddle(20, 3) → [5] -> [15] -> [10] -> [20]

Вывод:
text5
5 10
5 15 10
5 15 10 20
Тестирование

Измените main, чтобы вставить узлы на разные позиции.
Проверьте вывод printList() для проверки структуры списка.
Для проверки многопоточности создайте потоки, вызывающие insertIntoMiddle (нужен дополнительный код).

Примечания

Список предполагается непустым (по условию задачи).
Деструктор не потокобезопасен. Для продакшена добавьте блокировки.
Код учебный, для реального использования нужна дополнительная обработка ошибок.
